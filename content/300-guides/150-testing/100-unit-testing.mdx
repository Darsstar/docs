---
title: 'Unit testing'
metaTitle: 'Unit testing with Prisma'
metaDescription: 'Learn how to setup and run unit tests with the Prisma client'
tocDepth: 3
---

<TopBlock>

Unit testing aims to isolate a small portion of code and test it for logically predictable behaviors. In the context of Prisma, this generally means testing a function which makes database calls using the Prisma client. A single test should focus on the data returned by the Prisma client and how the function handles that data, ensuring that it behaves as expected.

This means that you should aim to remove as many dependencies as possible, such as external services and databases, to keep the tests and their environments as lightweight as possible.

</TopBlock>

#### Prerequisites

This guide assumes you have the JavaScript testing library [`Jest`](https://jestjs.io/) already setup in your project. If you do not then the following short guide will help you to get up and running.

<details><summary>Add Jest to your project</summary>

Prisma uses TypeScript and Jest supports TypeScript via Babel. Add the following dependencies to install Jest, Babel presets and a types module:

```terminal
npm install --save-dev jest @babel/preset-typescript babel-jest @babel/core @babel/preset-env @types/jest
```

Next create a `babel.config.js` file at your projects root, adding the following configuration:

```js file=babel.config.js
module.exports = {
  presets: [['@babel/preset-env', { targets: { node: 'current' } }], +'@babel/preset-typescript'],
}
```

Add a script to your `package.json` file which will run the tests. The `-i` flag will ensure that the tests are run one at a time to avoid any race conditions. The scripts will look for a folder at your projects root called `__tests__` (double\_\_underscore), and run any tests within files, within that folder.

```json file=package.json
  "scripts": {
    ...otherScripts
    "test": "jest -i"
  },
```

</details>

## Mocking the Prisma client

To ensure your unit tests are isolated from external factors you can mock the Prisma client, this means you get the benefits of being able to use your schema (**_type-safety_**), without having to make actual calls to your database when your tests are run.

This guide will cover two approaches to mocking the client, a singleton instance and dependency injection. Both have their merits depending on your use cases. To help with mocking the client the [`jest-mock-extended`](https://github.com/marchaos/jest-mock-extended) package will be used.

```terminal
npm install jest-mock-extended --save-dev
```

### Singleton

Create a file called `singleton.ts` at your projects root and add the following class:

```ts file=singleton.ts
import { PrismaClient } from '@prisma/client'
import { MockProxy, mockDeep } from 'jest-mock-extended'

export class MockClient {
  // A static property to store the instance
  static instance: MockClient

  // A deep mock of the Prisma client. This will be available on the instance
  public prisma = mockDeep<PrismaClient>()

  // A private constructor so the instance cant be instantiated many times.
  private constructor() {}

  // Public method to use the instance of the class
  public static getMockInstance(): MockClient {
    if (!MockClient.instance) {
      MockClient.instance = new MockClient()
    }

    return MockClient.instance
  }
}
```

The singleton class has a static property which is used internally to create a new instance. This property uses the `mockDeep` method from `jest-mock-extended` to enable access to the objects and methods available on the Prisma client.

The constructor is set to private to prevent it be instantiated many times and a public method is declared which allows the user to get a single instance of the class.

To use the singleton instance you would do the following in your test file:

```ts
import { MockClient } from './singleton'

const mockClient = MockClient.getMockInstance()
```

### Dependency injection

Create a `context.ts` file and add the following:

```ts file=context.ts
import { PrismaClient } from '@prisma/client'
import { MockProxy, mockDeep } from 'jest-mock-extended'

export type Context = {
  prisma: PrismaClient
}

export type MockContext = {
  prisma: MockProxy<PrismaClient>
}

export const createMockContext = (): MockContext => {
  return {
    prisma: mockDeep<PrismaClient>(),
  }
}
```

To use the context, you would do the following in your test file:

```ts
import { MockContext, Context, createMockContext } from '../context'

let mockCtx: MockContext
let ctx: Context

beforeEach(() => {
  mockCtx = createMockContext()
  ctx = (mockCtx as unknown) as Context
})
```

This will create a new context before each test is run via the `createMockContext` function. This (`mockCtx`) context will be used to make a mock call to Prisma and run a query to test. The `ctx` context will be used to run a scenario query that is tested against.

## Example unit tests

Prisma already tests query functions like `findMany`. A real world use case for unit testing Prisma might be a signup form. Your user fills in a form which calls a function, which in turn uses Prisma to make a call to your database.

All of the examples that follow use the following schema model:

```prisma file=schema.prisma
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```

The following unit tests will mock the process of

- Creating a new user
- Updating a users name

```ts file=functions-to-test.ts
import { PrismaClient } from '@prisma/client'

interface CreateUser {
  name: string
  email: string
}

// This function mocks us creating a user in the db
export function createUser(user: CreateUser, ctx: PrismaClient) {
  return ctx.user.create({
    data: user,
  })
}

interface UpdateUser {
  id: number
  name: string
  email: string
}

// This function mocks updating a user in the db
export function updateUsername(user: UpdateUser, ctx: PrismaClient) {
  return ctx.user.update({
    where: { id: user.id },
    data: user,
  })
}
```

<TabbedContent tabs={[<FileWithIcon text="with-singleton.ts" icon="file"/>, <FileWithIcon text="with-dependency-injection" icon="file"/>]}>

<tab>

```ts
import { createUser, updateUsername } from './functions-to-test.ts'
import { MockClient } from './singleton'

const mockClient = MockClient.getMockInstance()

test('should create new user ', async () => {
  const user = { id: 1, name: 'Rich', email: 'hello@prisma.io' }
  mockClient.prisma.user.create.mockResolvedValue(user)

  await expect(createUser(user, mockClient.prisma)).resolves.toEqual({
    id: 1,
    name: 'Rich',
    email: 'hello@prisma.io',
  })
})

test('should update a users name ', async () => {
  const user = { id: 1, name: 'Rich Haines', email: 'hello@prisma.io' }
  mockClient.prisma.user.update.mockResolvedValue(user)

  await expect(updateUsername(user, mockClient.prisma)).resolves.toEqual({
    id: 1,
    name: 'Rich Haines',
    email: 'hello@prisma.io',
  })
})
```

</tab>

<tab>

```ts
import { MockContext, Context, createMockContext } from './context'
import { createUser, updateUsername } from './functions-to-test.ts'

let mockCtx: MockContext
let ctx: Context

beforeEach(() => {
  mockCtx = createMockContext()
  ctx = (mockCtx as unknown) as Context
})

test('should create new user ', async () => {
  const user = { id: 1, name: 'Rich', email: 'hello@prisma.io' }
  mockCtx.prisma.user.create.mockResolvedValue(user)

  await expect(createUser(user, ctx.prisma)).resolves.toEqual({
    id: 1,
    name: 'Rich',
    email: 'hello@prisma.io',
  })
})

test('should update a users name ', async () => {
  const user = { id: 1, name: 'Rich Haines', email: 'hello@prisma.io' }
  mockCtx.prisma.user.update.mockResolvedValue(user)

  await expect(updateUsername(user, ctx.prisma)).resolves.toEqual({
    id: 1,
    name: 'Rich Haines',
    email: 'hello@prisma.io',
  })
})
```

</tab>

</TabbedContent>

## Using <inlinecode>Prisma.validator</inlinecode> for type-safe testing

When writing tests it helps greatly that you can take advantage of Prismas type-safety. The above examples manually create interfaces to keep the mock functions type-safe. Using the [`Prisma.validator`](../../concepts/components/prisma-client/advanced-type-safety/prisma-validator) you can let Prisma handle this logic for you.

The following example converts the create user unit test to use `Prisma.validator`.

> Note the adding of the `id` field outside of the `user` object. This is because our schema requires the `id` field to be present. In a real world scenario this would be auto-incremented and added by Prisma.

```ts file=__tests__/unit-tests.ts
import { MockContext, Context, createMockContext } from '../context'
import { Prisma } from '@prisma/client'

// This function mocks us creating a user in the db
function createUser(user: Prisma.UserCreateInput, ctx: Context) {
  return ctx.prisma.user.create({
    data: user,
  })
}

beforeEach(() => {
  mockCtx = createMockContext()
  ctx = (mockCtx as unknown) as Context
})

test('should create new user using the validator', async () => {
  const user = Prisma.validator<Prisma.UserCreateInput>()({
    name: 'Rich',
    email: 'hello@prisma.io',
  })

  mockCtx.prisma.user.create.mockResolvedValue({
    id: 1,
    ...user,
  })

  await expect(createUser(user, ctx)).resolves.toEqual({
    id: 1,
    name: 'Rich',
    email: 'hello@prisma.io',
  })
})
```

The `createUser` functions `user` input parameter is typed using the Prisma namespace type `Prisma.UserCreateInput`. This automatically ensures that you cannot add any fields that are not expected when running the `create` query. The same type is used in the `Prisma.validator`, making the test type-safe by taking advantage of Prisma in-built typings.
